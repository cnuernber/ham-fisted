<!DOCTYPE html PUBLIC ""
    "">
<html><head><meta charset="UTF-8" /><title>ham-fisted.defprotocol documentation</title><script async="true" src="https://www.googletagmanager.com/gtag/js?id=G-XJYNJF48RM"></script><script>window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'G-XJYNJF48RM');</script><link rel="stylesheet" type="text/css" href="css/default.css" /><link rel="stylesheet" type="text/css" href="highlight/solarized-light.css" /><script type="text/javascript" src="highlight/highlight.min.js"></script><script type="text/javascript" src="js/jquery.min.js"></script><script type="text/javascript" src="js/page_effects.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body><div id="header"><h2>Generated by <a href="https://github.com/weavejester/codox">Codox</a> with <a href="https://github.com/xsc/codox-theme-rdash">RDash UI</a> theme</h2><h1><a href="index.html"><span class="project-title"><span class="project-name">Ham-Fisted</span> <span class="project-version">3.002</span></span></a></h1></div><div class="sidebar primary"><h3 class="no-link"><span class="inner">Project</span></h3><ul class="index-link"><li class="depth-1 "><a href="index.html"><div class="inner">Index</div></a></li></ul><h3 class="no-link"><span class="inner">Topics</span></h3><ul><li class="depth-1 "><a href="Reductions.html"><div class="inner"><span>Reductions</span></div></a></li></ul><h3 class="no-link"><span class="inner">Namespaces</span></h3><ul><li class="depth-1"><div class="no-link"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>ham-fisted</span></div></div></li><li class="depth-2 branch"><a href="ham-fisted.api.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>api</span></div></a></li><li class="depth-2 branch"><a href="ham-fisted.bloom-filter.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>bloom-filter</span></div></a></li><li class="depth-2 branch current"><a href="ham-fisted.defprotocol.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>defprotocol</span></div></a></li><li class="depth-2 branch"><a href="ham-fisted.function.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>function</span></div></a></li><li class="depth-2 branch"><a href="ham-fisted.hlet.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>hlet</span></div></a></li><li class="depth-2 branch"><a href="ham-fisted.iterator.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>iterator</span></div></a></li><li class="depth-2 branch"><a href="ham-fisted.lazy-noncaching.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>lazy-noncaching</span></div></a></li><li class="depth-2 branch"><a href="ham-fisted.mut-map.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>mut-map</span></div></a></li><li class="depth-2 branch"><a href="ham-fisted.primitive-invoke.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>primitive-invoke</span></div></a></li><li class="depth-2 branch"><a href="ham-fisted.protocols.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>protocols</span></div></a></li><li class="depth-2 branch"><a href="ham-fisted.reduce.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>reduce</span></div></a></li><li class="depth-2"><a href="ham-fisted.set.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>set</span></div></a></li></ul></div><div class="sidebar secondary"><h3><a href="#top"><span class="inner">Public Vars</span></a></h3><ul><li class="depth-1"><a href="ham-fisted.defprotocol.html#var-defprotocol"><div class="inner"><span>defprotocol</span></div></a></li><li class="depth-1"><a href="ham-fisted.defprotocol.html#var-extend"><div class="inner"><span>extend</span></div></a></li><li class="depth-1"><a href="ham-fisted.defprotocol.html#var-extend-protocol"><div class="inner"><span>extend-protocol</span></div></a></li><li class="depth-1"><a href="ham-fisted.defprotocol.html#var-extend-type"><div class="inner"><span>extend-type</span></div></a></li><li class="depth-1"><a href="ham-fisted.defprotocol.html#var-extenders"><div class="inner"><span>extenders</span></div></a></li><li class="depth-1"><a href="ham-fisted.defprotocol.html#var-extends.3F"><div class="inner"><span>extends?</span></div></a></li><li class="depth-1"><a href="ham-fisted.defprotocol.html#var-find-protocol-cache-method"><div class="inner"><span>find-protocol-cache-method</span></div></a></li><li class="depth-1"><a href="ham-fisted.defprotocol.html#var-find-protocol-method"><div class="inner"><span>find-protocol-method</span></div></a></li><li class="depth-1"><a href="ham-fisted.defprotocol.html#var-satisfies.3F"><div class="inner"><span>satisfies?</span></div></a></li></ul></div><div class="namespace-docs" id="content"><h1 class="anchor" id="top">ham-fisted.defprotocol</h1><div class="doc"><div class="markdown"><p>Alternative protocol implementation.</p>
<p>Major features:</p>
<ul>
<li>
<p>Allows subclasses to override only a subset of the methods and if the superclass
has overridden the method then the superclasses implementation will be used.</p>
</li>
<li>
<p>Supports primitive typehints on function arguments and return values.</p>
</li>
<li>
<p>Much higher and more predictable multithreaded performance for protocol method invocation due to
the fewer number of global variables that are read and written to for a single protocol method
invocation.  Does not write to global variables on a per-call basis meaning far less cpu/cache traffic
in high contention scenarios.</p>
</li>
<li>
<p>Attempting to extend a protocol method that doesn't exist is an error at extension time.</p>
</li>
<li>
<p>Overriding the protocol for the base object array class overrides it for all things convertible
to object array while still allowing the concrete array type to match a specific override.</p>
</li>
</ul>
<p>Another design decision is to avoid the interface check - this simplifes the hot path a slight bit
at the cost of slightly slower calltimes in the case the interface is used.  For those cases often
it is possible to simply typehint the interface and call it directly avoiding any protocol dispatch
overhead.</p>
<p>Additional call overhead above and beyond a normal fn invocation in an arm mac is <code>-6ns</code> - the time
for <code>.getClass</code> call into single concurrent hash map lookup.</p>
</div></div><div class="public anchor" id="var-defprotocol"><h3>defprotocol</h3><h4 class="type">macro</h4><h4 class="added">added in 1.2</h4><div class="usage"><code>(defprotocol name &amp; opts+sigs)</code></div><div class="doc"><div class="markdown"><p>A protocol is a named set of named methods and their signatures:</p>
<pre><code class="language-clojure">  (defprotocol AProtocolName

    ;optional doc string
    "A doc string for AProtocol abstraction"

   ;options
   :extend-via-metadata true

  ;method signatures
    (bar [this a b] "bar docs")
    (baz [this a] [this a b] [this a b c] "baz docs"))
</code></pre>
<p>No implementations are provided. Docs can be specified for the
protocol overall and for each method. The above yields a set of
polymorphic functions and a protocol object. All are
namespace-qualified by the ns enclosing the definition The resulting
functions dispatch on the type of their first argument, which is
required and corresponds to the implicit target object ('this' in
Java parlance). defprotocol is dynamic, has no special compile-time
effect, and defines no new types or classes. Implementations of
the protocol methods can be provided using extend.</p>
<p>When :extend-via-metadata is true, values can extend protocols by
adding metadata where keys are fully-qualified protocol function
symbols and values are function implementations. Protocol
implementations are checked first for direct definitions (defrecord,
deftype, reify), then metadata definitions, then external
extensions (extend, extend-type, extend-protocol)</p>
<p>defprotocol will automatically generate a corresponding interface,
with the same name as the protocol, i.e. given a protocol:
my.ns/Protocol, an interface: my.ns.Protocol. The interface will
have methods corresponding to the protocol functions, and the
protocol will automatically work with instances of the interface.</p>
<p>Note that you should not use this interface with deftype or
reify, as they support the protocol directly:</p>
<pre><code class="language-clojure">
  (defprotocol P
    (foo [this])
    (bar-me [this] [this y]))

  (deftype Foo [a b c]
   P
    (foo [this] a)
    (bar-me [this] b)
    (bar-me [this y] (+ c y)))

  (bar-me (Foo. 1 2 3) 42)
  =&gt; 45

  (foo
    (let [x 42]
      (reify P
        (foo [this] 17)
        (bar-me [this] x)
        (bar-me [this y] x))))
  =&gt; 17
</code></pre>
</div></div><div class="src-link"><a href="https://github.com/cnuernber/ham-fisted/blob/master/src/ham_fisted/defprotocol.clj#L264">view source</a></div></div><div class="public anchor" id="var-extend"><h3>extend</h3><h4 class="added">added in 1.2</h4><div class="usage"><code>(extend atype &amp; proto+mmaps)</code></div><div class="doc"><div class="markdown"><p>Implementations of protocol methods can be provided using the extend construct:</p>
<pre><code class="language-clojure">  (extend AType
    AProtocol
     {:foo an-existing-fn
      :bar (fn [a b] ...)
      :baz (fn ([a]...) ([a b] ...)...)}
    BProtocol
      {...}
    ...)
</code></pre>
<p>extend takes a type/class (or interface, see below), and one or more
protocol + method map pairs. It will extend the polymorphism of the
protocol's methods to call the supplied methods when an AType is
provided as the first argument.</p>
<p>Method maps are maps of the keyword-ized method names to ordinary
fns. This facilitates easy reuse of existing fns and fn maps, for
code reuse/mixins without derivation or composition. You can extend
an interface to a protocol. This is primarily to facilitate interop
with the host (e.g. Java) but opens the door to incidental multiple
inheritance of implementation since a class can inherit from more
than one interface, both of which extend the protocol. It is TBD how
to specify which impl to use. You can extend a protocol on nil.</p>
<p>If you are supplying the definitions explicitly (i.e. not reusing
exsting functions or mixin maps), you may find it more convenient to
use the extend-type or extend-protocol macros.</p>
<p>Note that multiple independent extend clauses can exist for the same
type, not all protocols need be defined in a single extend call.</p>
<p>See also:
extends?, satisfies?, extenders</p>
</div></div><div class="src-link"><a href="https://github.com/cnuernber/ham-fisted/blob/master/src/ham_fisted/defprotocol.clj#L361">view source</a></div></div><div class="public anchor" id="var-extend-protocol"><h3>extend-protocol</h3><h4 class="type">macro</h4><h4 class="added">added in 1.2</h4><div class="usage"><code>(extend-protocol p &amp; specs)</code></div><div class="doc"><div class="markdown"><p>Useful when you want to provide several implementations of the same
protocol all at once. Takes a single protocol and the implementation
of that protocol for one or more types. Expands into calls to
extend-type:</p>
<pre><code class="language-clojure">  (extend-protocol Protocol
    AType
      (foo [x] ...)
      (bar [x y] ...)
    BType
      (foo [x] ...)
      (bar [x y] ...)
    AClass
      (foo [x] ...)
      (bar [x y] ...)
    nil
      (foo [x] ...)
      (bar [x y] ...))
</code></pre>
<p>expands into:</p>
<pre><code class="language-clojure">  (do
   (clojure.core/extend-type AType Protocol
     (foo [x] ...)
     (bar [x y] ...))
   (clojure.core/extend-type BType Protocol
     (foo [x] ...)
     (bar [x y] ...))
   (clojure.core/extend-type AClass Protocol
     (foo [x] ...)
     (bar [x y] ...))
   (clojure.core/extend-type nil Protocol
     (foo [x] ...)
     (bar [x y] ...)))
</code></pre>
</div></div><div class="src-link"><a href="https://github.com/cnuernber/ham-fisted/blob/master/src/ham_fisted/defprotocol.clj#L530">view source</a></div></div><div class="public anchor" id="var-extend-type"><h3>extend-type</h3><h4 class="type">macro</h4><h4 class="added">added in 1.2</h4><div class="usage"><code>(extend-type t &amp; specs)</code></div><div class="doc"><div class="markdown"><p>A macro that expands into an extend call. Useful when you are
supplying the definitions explicitly inline, extend-type
automatically creates the maps required by extend.  Propagates the
class as a type hint on the first argument of all fns.</p>
<pre><code class="language-clojure">  (extend-type MyType
    Countable
      (cnt [c] ...)
    Foo
      (bar [x y] ...)
      (baz ([x] ...) ([x y &amp; zs] ...)))
</code></pre>
<p>expands into:</p>
<pre><code class="language-clojure">
  (extend MyType
   Countable
     {:cnt (fn [c] ...)}
   Foo
     {:baz (fn ([x] ...) ([x y &amp; zs] ...))
      :bar (fn [x y] ...)})
</code></pre>
</div></div><div class="src-link"><a href="https://github.com/cnuernber/ham-fisted/blob/master/src/ham_fisted/defprotocol.clj#L493">view source</a></div></div><div class="public anchor" id="var-extenders"><h3>extenders</h3><div class="usage"><code>(extenders protocol)</code></div><div class="doc"><div class="markdown"><p>Returns a collection of the types explicitly extending protocol</p>
</div></div><div class="src-link"><a href="https://github.com/cnuernber/ham-fisted/blob/master/src/ham_fisted/defprotocol.clj#L66">view source</a></div></div><div class="public anchor" id="var-extends.3F"><h3>extends?</h3><div class="usage"><code>(extends? protocol atype)</code></div><div class="doc"><div class="markdown"><p>Returns true if atype extends protocol</p>
</div></div><div class="src-link"><a href="https://github.com/cnuernber/ham-fisted/blob/master/src/ham_fisted/defprotocol.clj#L60">view source</a></div></div><div class="public anchor" id="var-find-protocol-cache-method"><h3>find-protocol-cache-method</h3><div class="usage"><code>(find-protocol-cache-method protocol cache x)</code></div><div class="doc"><div class="markdown"></div></div><div class="src-link"><a href="https://github.com/cnuernber/ham-fisted/blob/master/src/ham_fisted/defprotocol.clj#L36">view source</a></div></div><div class="public anchor" id="var-find-protocol-method"><h3>find-protocol-method</h3><div class="usage"><code>(find-protocol-method protocol methodk x)</code></div><div class="doc"><div class="markdown"><p>It may be more efficient in a tight loop to bypass the protocol dispatch on a per-call basis.</p>
</div></div><div class="src-link"><a href="https://github.com/cnuernber/ham-fisted/blob/master/src/ham_fisted/defprotocol.clj#L47">view source</a></div></div><div class="public anchor" id="var-satisfies.3F"><h3>satisfies?</h3><div class="usage"><code>(satisfies? protocol x)</code></div><div class="doc"><div class="markdown"><p>Returns true if x satisfies the protocol</p>
</div></div><div class="src-link"><a href="https://github.com/cnuernber/ham-fisted/blob/master/src/ham_fisted/defprotocol.clj#L71">view source</a></div></div></div></body></html>